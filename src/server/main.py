""" Nitro Enclave and Attestation integration with KMS Sample """

import base64
import json
import socket
from Crypto.Cipher import AES
from kms import NitroKms

ENCLAVE_PORT = 5000

"""Client-side AES encryption"""

def add_to_16(value):
    while len(value) % 16 != 0:
        value += '\0'
    return str.encode(value)  # return bytes

# Use client-side AES to encrypt plain text
def encrypt(key, text):
    aes = AES.new(add_to_16(key), AES.MODE_ECB)  # Initialize encryption method
    encrypt_aes = aes.encrypt(add_to_16(text))  # Execute Encryption, return bytes
    encrypted_text = str(base64.encodebytes(encrypt_aes), encoding='utf-8')  # return base64 encoded string
    return encrypted_text

# Use client-side AES to decrypt encrypted text
def decrypt(key, text):
    aes = AES.new(add_to_16(key), AES.MODE_ECB)  # Initialize decryption method
    base64_decrypted = base64.decodebytes(text.encode(encoding='utf-8'))  # Execute Decryption, return bytes
    decrypted_text = str(aes.decrypt(base64_decrypted), encoding='utf-8').replace('\0', '')  # return base64 encoded string
    return decrypted_text


"""Run the nitro enclave application."""

def main():
    # Bind and listen on vsock.
    vsock = socket.socket(socket.AF_VSOCK, socket.SOCK_STREAM) # pylint:disable=no-member
    vsock.bind((socket.VMADDR_CID_ANY, ENCLAVE_PORT)) # pylint:disable=no-member
    vsock.listen()

    # Initialize a KMS class
    nitro_kms = NitroKms()
    print('Listening...')

    while True:
        conn, _addr = vsock.accept()
        print('Received new connection')
        payload = conn.recv(4096)

        # Load the JSON data provided over vsock
        try:
            client_request = json.loads(payload.decode())
        except Exception as exc: # pylint:disable=broad-except
            msg = f'Exception ({type(exc)}) while loading JSON data: {str(exc)}'
            content = {
                'success': False,
                'error': msg
            }
            conn.send(str.encode(json.dumps(content)))
            conn.close()
            continue
        # Get AWS Credential from Socket
        kms_credentials = client_request['credential']
        # Get AWS KMS Key ID from Socket
        key_id = client_request['keyid']
        # Set environment variables
        nitro_kms.set_region('ap-east-1')
        nitro_kms.set_credentials(kms_credentials)
        
        # Generate text by KMS GenerateRandom API with attestation
        random = nitro_kms.kms_generate_random(8)  # return bytes
        plaintext = base64.b64encode(random).decode('utf-8')  # bytes to string

        # Generate data key by KMS GenerateDataKey API with attestation
        datakey = nitro_kms.kms_generate_data_key(24, key_id)  # return bytes
        plain_datakey = base64.b64encode(datakey).decode('utf-8') # bytes to string

        """Server side encrypt and decrypt by KMS"""
        # Encrypt text(from GenerateRandom) by KMS Encrypt API
        kms_encrypted = nitro_kms.kms_encrypt(random, key_id)  # Input plaintext bytes and KMS keyID

        # Decrypt encrypted text(by KMS:Encrypt) by KMS Decrypt API with attestation
        kms_decrypted = nitro_kms.kms_decrypt(kms_encrypted['CiphertextBlob'])  # Key metadata included in CiphertextBlob

        """Client side encrypt and decrypt by AES"""
        # Encrypt text(GenerateRandom) by client-side AES
        aes_encrypted = encrypt(plain_datakey, plaintext) # Input datakey string and plaintext string

        # Decrypt text(GenerateRandom) by client-side AES
        aes_decrypted = decrypt(plain_datakey, aes_encrypted) # Input datakey string and encrypted string


        # Return Plaintext, Encrypted text, and Decrypted plaintext
        content = {
            'Plaintext generated by KMS GenerateRandom': plaintext,
            'Encrypted by KMS Encrypt': kms_encrypted['CiphertextBlob'],
            'Decrypted by KMS Decrypt': base64.b64encode(kms_decrypted).decode('utf-8'),
            'Encrypted by client-side AES with KMS GenerateDataKey ': aes_encrypted,
            'Decrypted by client-side AES with KMS GenerateDataKey ': aes_decrypted
        }
        print(content)
        
        # Send out returned data to Socket
        conn.send(str.encode(json.dumps(content)))
        conn.close()
        print('Closed connection')

if __name__ == '__main__':
    main()
